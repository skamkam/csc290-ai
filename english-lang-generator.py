# CSC290 Assignment 4 - "English" Generator
# Authors: Amanda Colby, Asher Uman, Sarah Kam

import random

# State: the way we are storing each state in the FSA with accept boolean
# and dictionary of potential transitions
class State:
  def __init__(self, accept:bool, transitions:dict):
    self.accept = accept
    self.transitions = transitions

def terminalGenerate(keyword:str):
  """
  Function that chooses a part of speech from a list of potential words

  :param keyword: (str) A part of speech, such as "ADJ"
  :return : (str) A word that is that part of speech
  """
  terminalWords = {"AUX": [" can", " may", " might", " will", " would", " does", " could", " should"],
                   "PERIOD": ["."],
                   "QUESTION-MARK": ["?"],
                   "DET": [" a", " an", " the", " another"],
                   "ADJ": [" red", " chewy", " limp", " itchy", " juicy", " silly", " squiggly", " delightful"],
                   "N": [" cthulhu", " rat king", " girl", " jamie macbeth", " orangutan", " imposter"],
                   "PREP": [" in", " of", " to", " behind", " over", " within", " under"],
                   "V": [" eat", " chase", " swim", " stare", " slouch"],
                   "COMMA": [","],
                   "WP": [" who", " which", " whom", " that", " whose"],
                   "ADV": [" flightily", " hungrily", " icily", " lazily", " incorrectly"]}
  return random.choice(terminalWords[keyword])

def generate(lang:list):
  """
  Given an FSA as defined by our chosen objects, generates a sentence

  :param lang: (list) the FSA
  :return : (str) A sentence generated by the FSA
  """
  
  sentence = ""
  curr_state = lang[0]

  while True:
    # if we're on an accept state w/ transitions, might acc word
    # or if we're on an accept state w/o transitions, must acc word

    if curr_state.accept:
      if random.randint(0,10) < 8 or len(curr_state.transitions.keys()) == 0:
        return sentence
        
    # otherwise, choose one of the states we can go to, and append
    # the appropriate letter to go with that state
    trans_choice = random.choice(list(curr_state.transitions.keys()))
    # this is the next part of the sentence
    word = random.choice(curr_state.transitions[trans_choice])
    if word in ["AUX", "PERIOD", "QUESTION-MARK", "DET", "ADJ", "N", "PREP", "V", "COMMA", "WP", "ADV"]:
      sentence += terminalGenerate(word)
      #choose an appropriate word
    else:
      if word == "NP":
        sentence += generate(fsn2lang)
      elif word == "PP":
        sentence += generate(fsn3lang)
      elif word == "VP":
        sentence += generate(fsn4lang)
      elif word == "WHNP":
        sentence += generate(fsn5lang)
    
    # go to trans choice state
    curr_state = lang[trans_choice]
    # choose between stopping and going to another letter

def fsn_S():
  """
  Builds an FSN that generates the following sequence:
  NP + (AUX) + VP + PERIOD   |  AUX + NP + VP + QUESTION-MARK
  """
  # coinflip for np or aux at the beginning, then branches
  # aux is a bonus state
  start = State(False, {1: ["NP"], 5: ["AUX"]})  # 1 is 1st branch, 6 is 2nd

  br1frnp = State(False, {2: ["AUX"], 3: ["VP"]})
  br1fraux = State(False, {3: ["VP"]})
  br1frvp = State(False, {4: ["PERIOD"]})
  br1frperiod = State(True, {})

  br2fraux = State(False, {6: ["NP"]})
  br2frnp = State(False, {7: ["VP"]})
  br2frvp = State(False, {8: ["QUESTION-MARK"]})
  br2frquestion = State(True, {})

  language = [start, br1frnp, br1fraux, br1frvp, br1frperiod,
              br2fraux, br2frnp, br2frvp, br2frquestion]
  return language

def fsn_NP():
  """
  Builds an FSN that generates: 
  (DET) + (ADJ*) + N + (PP) + (WHNP)
  """
  start = State(False, {1: ["DET"], 2: ["ADJ"], 3: ["N"]})
  det = State(False, {2: ["ADJ"], 3: ["N"]})
  adj = State(False, {2: ["ADJ"], 3: ["N"]})
  n = State(True, {4: ["PP"], 5: ["WHNP"]})
  pp = State(True, {5:["WHNP"]})
  whnp = State(True, {})

  language = [start, det, adj, n, pp, whnp]
  return language

def fsn_PP():
  """
  Builds an FSN that generates:
  PREP + NP
  """
  start = State(False, {1: ["PREP"]})
  prep = State(False, {2: ["NP"]})
  np = State(True, {})

  lang = [start, prep, np]
  return lang

def fsn_VP():
  """
  Builds the following FSN
  V + (NP) + (PP*)  |  V + ADV
  """
  start = State(False, {1: ["V"], 2: ["V"], 3: ["V"]})
  br1frv = State(True, {2: ["NP"]})
  br1frnp = State(True, {2: ["PP"]})

  br2frv = State(False, {4: ["ADV"]})
  br2fradv = State(True, {})

  language = [start, br1frv, br1frnp, br2frv, br2fradv]
  return language

def fsn_WHNP():
  """
  Generates the FSN for
  COMMA + WP + (NP) + AUX + VP + COMMA
  """
  start = State(False, {1: ["COMMA"]})
  wp = State(False, {2: ["WP"], 3:["WP"]})
  np = State(False, {3:["NP"]})
  aux = State(False, {4:["AUX"]})
  vp = State(False, {5:["VP"]})
  comma = State(False, {6: ["COMMA"]})
  end = State(True, {})

  language = [start, wp, np, aux, vp, comma, end]
  return language

# FSNs: 
fsn1lang = fsn_S()
fsn2lang = fsn_NP()
fsn3lang = fsn_PP()
fsn4lang = fsn_VP()
fsn5lang = fsn_WHNP()

def main():
  for x in range(50):
    print(generate(fsn1lang))


if __name__ == "__main__": 
  main()