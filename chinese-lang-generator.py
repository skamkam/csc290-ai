# CSC290 Final Project - Extended Sentence Generator (Chinese)
# Authors: Amanda Colby, Asher Uman, Sarah Kam
# 
# Transforming the English Language Generator grammar and word sets to create a random sentence generator in another language: Chinese

import random

# State: the way we are storing each state in the FSA with accept boolean
# and dictionary of potential transitions
class State:
  def __init__(self, accept:bool, transitions:dict):
    self.accept = accept
    self.transitions = transitions

def terminalGenerate(keyword:str):
  """
  Function that chooses a part of speech from a list of potential words

  :param keyword: (str) A part of speech, such as "verb"
  :return : (str) A word that is that part of speech
  """
  terminalWords = {"verb": ["吃", "喜欢", "看", "炸", "选", "爱"],
      "verb-negate-verb": ["吃不吃", "喜欢不喜欢", "看不看", "选不选", "爱不爱", "炸不炸"],
      "descriptor": ["红色", "长", "漂亮", "丑", "贵", "小", "苦", "辣", "冷", "可爱"], # adjective
      "noun": ["苹果", "猫", "铅笔", "老鼠", "老师", "订书机", "他", "她", "音乐", "舞会", "大学"],
      "past tense": ["了"], # part of speech that makes it past tense
      "and": ["和"],
      "question part": ["吗"], # turns a sentence into a question
      "intensifier": ["很", "非常"], # "very", "really"
      "softener": ["一点"], # "a little bit", softens a statement/question
      "negate": ["不", "没"], # negates a sentence, like "not"
      "possessive": ["的"],
      "adverbizer": ["得"], # applies a descriptor to a verb
      "preposition": ["里面", "外面", "左边", "右边", "上面", "后面"],
      "period": ["。"],
      "question mark": ["？"]}
  return random.choice(terminalWords[keyword])

def generate(lang:list):
  """
  Given an FSA as defined by our chosen objects, generates a sentence

  :param lang: (list) the FSA
  :return : (str) A sentence generated by the FSA
  """

  sentence = ""
  curr_state = lang[0]

  while True:
    # if we're on an accept state w/ transitions, might acc word
    # or if we're on an accept state w/o transitions, must acc word

    if curr_state.accept:
      if random.randint(0,10) < 7 or len(curr_state.transitions.keys()) == 0:
        return sentence

    # otherwise, choose one of the states we can go to, and append
    # the appropriate letter to go with that state
    trans_choice = random.choice(list(curr_state.transitions.keys()))
    # next part of the sentence
    word = random.choice(curr_state.transitions[trans_choice])
    if word in ["verb", "verb-negate-verb", "descriptor", "noun", "past tense", "and",
      "question part", "intensifier", "softener", "negate", "possessive",
      "adverbizer", "preposition", "period", "question mark"]:
      sentence += terminalGenerate(word) #choose an appropriate word
    else:
      if word == "ST":
        sentence += generate(fsn_ST_lang)
      elif word == "Q1":
        sentence += generate(fsn_Q1_lang)
      elif word == "NP":
        sentence += generate(fsn_NP_lang)
      elif word == "VP":
        sentence += generate(fsn_VP_lang)
      elif word == "ADJ":
        sentence += generate(fsn_ADJ_lang)
      elif word == "ADV":
        sentence += generate(fsn_ADV_lang)
        
    # go to trans choice state
    curr_state = lang[trans_choice]
    # choose between stopping and going to another letter

def fsn_NP():
  """
  Builds an FSN that generates the following sequence:
  (ADJ)* + (preposition + possessive) + noun + (and + NP)*
  """
  start = State(False, {0: ["ADJ"], 1: ["preposition"], 3: ["noun"]}) # 0
  poss = State(False, {2: ["possessive"]}) # 1, have added a preposition
  noun = State(False, {3: ["noun"]}) # 2, have added a possessive
  acceptState = State(True, {4: ["and"]}) # 3, just added a noun
  np = State(False, {2:["NP"]}) # 4

  language = [start, poss, noun, acceptState, np]
  return language

def fsn_VP():
  """
  Builds an FSN that generates the following sequence:
  verb + (past tense ) + (softener) + (ADV)
  """
  start = State(False, {1:["verb"]}) #0
  acceptState = State(True, {2:["past tense"], 3:["softener"], 4:["NP"], 4:["ADV"]}) #1
  pastTense = State(True, {3:["softener"], 4:["NP"], 4:["ADV"]}) #2
  softener = State(True, {4:["ADV"]}) #3
  endState = State(True, {}) #4
  
  language = [start, acceptState, pastTense, softener, endState]
  return language

def fsn_ADJ():
  """
  Builds an FSN that generates the following sequence:
  (intensifier) + (negate) + descriptor + possessive
  """
  
  start = State(False, {1: ["intensifier"], 2: ["negate"], 3:["descriptor"]}) # 0
  intensifier = State(False, {2:["negate"], 3:["descriptor"]}) # 1
  negate = State(False, {3:["descriptor"]}) #2
  descriptor = State(False, {4:["possessive"]}) #3 
  acceptState = State(True, {}) #4

  language = [start, intensifier, negate, descriptor, acceptState]
  return language

def fsn_ADV():
  """
  Builds an FSN that generates the following sequence:
  adverbizer + (intensifier) + (negate) + descriptor
  """

  start = State(False, {1: ["adverbizer"]}) # 0
  adverbizer = State(False, {2:["intensifier"], 3:["negate"], 4:["descriptor"]}) #1
  intensifier = State(False, {3:["negate"], 4:["descriptor"]}) # 2
  negate = State(False, {4:["descriptor"]}) #3
  acceptState = State(True, {}) #4

  language = [start, adverbizer, intensifier, negate, acceptState]
  return language

def fsn_S():
  """
  Builds an FSN that generates the following sequence:
  S -> sentence | question 1 | question 2
  """
  
  start = State(False, {1:["ST"],2:["Q1"]})

  statement = State(True, {})
  question1 = State(True, {})

  language = [start, statement, question1]
  return language
  
def fsn_ST():
  """
  Builds an FSN that generates the following sequence:
  Statement -> NP + (intensifier | negate) + VP + NP + [PERIOD | (QUESTION-PART + QUESTION-MARK)]
  """

  start = State(False, {1:["NP"]})
  np = State(False, {2:["intensifier"], 3:["negate"]})
  inten = State(False, {4:["VP"]})
  neg = State(False, {4:["VP"]})
  vp = State(False, {5:["NP"]})
  np2 = State(False, {6:["period"], 7:["question part"]})
  per = State(True, {})
  qp = State(False, {8:["question mark"]})
  qm = State(True, {})

  language = [start, np, inten, neg, vp, np2, per, qp, qm]
  return language

def fsn_Q1():
  """
  Builds an FSN that generates the following sequence:
  question 1 -> NP + verb-negate-verb + NP + question mark
  """

  start = State(False, {1:["NP"]})
  np = State(False, {2:["verb-negate-verb"]})
  vp = State(False, {3: ["NP"]})
  np2 = State(False, {4:["question mark"]})
  qm = State(True, {})

  language = [start, np, vp, np2, qm]
  return language


# FSNs: 
fsn_S_lang = fsn_S()
fsn_ST_lang = fsn_ST()
fsn_Q1_lang = fsn_Q1()

fsn_NP_lang = fsn_NP()
fsn_VP_lang = fsn_VP()
fsn_ADJ_lang = fsn_ADJ()
fsn_ADV_lang = fsn_ADV()

def main():
  for x in range(50):
    print(generate(fsn_S_lang))

if __name__ == "__main__": 
  main()